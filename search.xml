<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[vue 分享记录]]></title>
      <url>https://jane0219.github.io/2017/02/04/vueShare/</url>
      <content type="html"><![CDATA[<p>本文是为了分享Vue相关知识点,从之前一篇<a href="http://chping.website/2016/11/28/Vue%E5%92%8CReact%E5%AF%B9%E6%AF%94/" target="_blank" rel="external">Vue和React对比</a>笔记中节选出来的。</p>
<a id="more"></a>
<p>一、数据双向绑定</p>
<p>1.插值表达式<br>2.指令系统（声明式绑定）<br>3.Class与Style绑定<br>4.条件渲染和列表渲染<br>5.时间处理器<br>6.表单控件<br>7.计算属性<br>8.数据获取（axios）</p>
<p>二、组件及数据流</p>
<p>1.创建组件<br>2.使用组件<br>3.生命周期<br>4.组件之间信息传递</p>
<p>三、状态管理</p>
<p>vuex</p>
<p>四、路由</p>
<p>vue-Router</p>
<p>五、其他</p>
<p>1.过渡系统<br>2.服务端渲染</p>
<h1 id="Vue-简单介绍"><a href="#Vue-简单介绍" class="headerlink" title="Vue 简单介绍"></a>Vue 简单介绍</h1><p>Vue也已经升级到2.0版本了，到现在为止，比较流行的MVVM框架有<strong>AngularJS</strong>（也有人认为其为MVC）、<strong>ReactJS</strong>和<strong>VueJS</strong>，这三个框架中，以我现在的情况来说（AngularJS2还没有去接触），Vue应该是发展最快的。</p>
<p>为什么现在MVVM框架这么火呢？JQuery挺好用的呀，为什么要去代替它？…</p>
<p>可能会产生这样的疑问，在我看来，MVVM框架的流行是因为随着前端技术的发展对于要求越来越高和前端面对的场景越来越复杂导致了现实对于前端性能的要求也越来越高，这样像JQuery那样频繁的操作DOM节点的方式显然就不太合适了。所以MVVM开始逐渐流行开来，另外我认为JQuery目前来看还是不会被代替的，因为对于一些对性能要求不是很高的前端项目，是用JQuery来开发还是非常爽的。</p>
<h1 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h1><p>1.插值表达式<br>2.指令系统（声明式绑定）<br>3.Class与Style绑定<br>4.条件渲染和列表渲染<br>5.时间处理器<br>6.表单控件<br>7.计算属性<br>8.数据获取（axios）</p>
<p>我理解的数据双向绑定是，MVVM框架中的View层和Model层的数据相互影响。那么，那些行为会引起数据变动呢？<br>首先，View层（即页面上）的<strong>表单操作</strong>、<strong>触发事件</strong>可能会引起数据变动；<strong>数据请求</strong>也可能会引起数据变动，这个变动我认为更多在Model层；还有一种情况就是，<strong>某一数据变动引起另外关联数据</strong>的改变。<br>不管是哪一种数据改变，都会导致View层和Model层的变化，View层变动引起页面变化，Model层变动保存数据。</p>
<h2 id="Vue的数据双向绑定"><a href="#Vue的数据双向绑定" class="headerlink" title="Vue的数据双向绑定"></a>Vue的数据双向绑定</h2><p>在Vue中，View层中与数据绑定有关的有<strong>插值表达式</strong>、<strong>指令系统</strong>、<strong>*Class和Style</strong>、<strong>事件处理器</strong>和<strong>表单控件</strong>，<strong>ajax请求</strong>和<strong>计算属性</strong>也和数据变化有关，下面我们分别说一下这些知识点设计的一些数据绑定问题。</p>
<h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><p>在Vue中，<strong>插值表达式</strong>和<strong>指令</strong>对于数据的操作又称为<strong>模板语法</strong>。</p>
<blockquote>
<p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>
<p>在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。</p>
</blockquote>
<p>关于插值表达式的使用，在<a href="http://cn.vuejs.org/v2/guide/syntax.html#插值l" target="_blank" rel="external">Vue官网模板语法的插值</a>部分有详细的使用说明，不在赘述，需要注意的是，<strong>过滤器</strong>在插值中的使用有时可以起到意想不到的效果。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>Vue重的指令估计是从Angular那里学来的，有很多相似的地方，但是也不完全相同。<br>Vue中的指令我觉着非常的简单，并且就12个，很容易记忆：</p>
<ol>
<li><strong>v-bind</strong>:动态地绑定一个或多个 <em>html属性</em>，或一个组件 <em>prop 到表达式</em>（组件单项数据流使用）。</li>
<li><strong>v-once</strong>:绑定只渲染元素和组件 <em>一次</em> 的特性或prop表达式。</li>
<li><strong>v-model</strong>:在表单控件或者组件上创建双向绑定，<em>代替value值</em>。</li>
<li><strong>v-text</strong>:更新元素的 <em>textContent</em>。</li>
<li><strong>v-html</strong>:更新元素的 <em>innerHTML</em>。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong> 。</li>
<li><strong>v-on</strong>:绑定事件监听器。</li>
<li><strong>v-if / v-else / v-show</strong>:条件渲染。</li>
<li><strong>v-for</strong>:列表渲染。</li>
<li><strong>v-pre</strong>:跳过这个元素和它的子元素的编译过程。<br>10 <strong>v-cloak</strong>:这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code>一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</li>
</ol>
<p>大概列举一下，详细使用请参考<a href="http://cn.vuejs.org/v2/api/#指令" target="_blank" rel="external">Vue API 指令</a>和<a href="http://cn.vuejs.org/v2/guide/" target="_blank" rel="external">Vue 指南的Class与Style绑定、条件渲染、列表渲染、事件处理器、表单控件绑定</a>部分内容。</p>
<h3 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h3><p>Vue为了方便操作控制元素的样式，专门增强了<strong>v-bind:class</strong>和<strong>v-bind:style</strong>,通过增强的这两个指令可以实用<strong>对象语法</strong>或者<strong>数组语法</strong>对元素的样式进行变动，这也不是本文重点，<a href="http://cn.vuejs.org/v2/guide/class-and-style.html" target="_blank" rel="external">Vue官方Class与Style绑定</a>已经说得很详细了。</p>
<h3 id="条件渲染和列表渲染"><a href="#条件渲染和列表渲染" class="headerlink" title="条件渲染和列表渲染"></a>条件渲染和列表渲染</h3><p>条件渲染和列表渲染在Vue模板中动态创建模板很不错，让我里面想到了JSP中的EL表达式和Struts中的JSTL(后端模板语言中基本都有)，这就可以方便的根据后端传过来的数据进行模板创建了。你懂得，详细语法和使用还是参考<a href="http://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="external">Vue文档列表渲染和条件渲染</a>，本篇主题是对比，并不是讲解基础语法，Vue的官方文档我觉着非常给力，简单明了。</p>
<h3 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h3><p>在Vue中我们可以通过<strong>v-on</strong>来给元素注册事件，完成<a href="http://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="external">事件注册</a>，Vue中的事件处理和平时使用的事件处理不同之处就是，既可以绑定数据处理函数，也可以使用内联处理器。并且，Vue还讲常用的事件方法，如<strong>preventDefault方法</strong>等通过修饰符的方式来方便使用。</p>
<h3 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h3><p>你可以用<strong>v-model</strong>指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>
<p>Vue中对于<a href="http://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="external">表单控件</a>提供的<em>v-model*</em>指令非常的使用，可以方便的返回或者设置表单控件的信息。</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>在Vue中引入了<strong>计算属性</strong>来处理模板中放入太多的逻辑会让模板过重且难以维护的问题，这样不但解决了上面的问题，而且也同时让模板和业务逻辑更好的分离。<br><a href="http://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="external">Vue计算属性</a></p>
<h3 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h3><p>在Vue1.x的版本中，官方推荐的ajax数据请求库是<strong>vue-resource</strong>，但是在Vue2.0的版本中，不再推荐使用，该推荐使用<strong><a href="https://github.com/mzabriskie/axios" target="_blank" rel="external">axios</a></strong>。</p>
<p>其实这些ajax数据请求的使用都大差不差，随你选择，并且<strong>vue-resource</strong>还是继续支持使用的，在Vue2.0中。</p>
<p>以上八个方面，我个人认为都是和数据绑定相关的一些Vue基本项，只是简单列举，具体内容请查看<a href="http://cn.vuejs.org/v2/guide" target="_blank" rel="external">Vue文档</a>或者<a href="http://cn.vuejs.org/v2/api/" target="_blank" rel="external">API</a>。<br>为什么这么多呢？因为Vue中有个<strong>模板</strong>的概念，所以，数据和模板进行数据绑定需要分别来做，而在的React中，你会发现，React的数据绑定虽然也是这八项功能点，但是其是通过JSX语法实现的。</p>
<h1 id="组件及数据流"><a href="#组件及数据流" class="headerlink" title="组件及数据流"></a>组件及数据流</h1><p>1.创建组件<br>2.使用组件<br>3.生命周期<br>4.组件之间信息传递</p>
<p>前端发展到现在，为了提高开发效率，组件化已经成为一个必然的趋势。而MVVM框架中，如果没有组件化的思想，它都不敢说拿出来宣传（纯属个人意淫）。下面我们再简单介绍一下VueJS中的<strong>组件思想</strong>和<strong>组件之间的数据流</strong>。</p>
<h2 id="React中的组件和数据流"><a href="#React中的组件和数据流" class="headerlink" title="React中的组件和数据流"></a>React中的组件和数据流</h2><p>上一节中提到过，React中的组件化是其重要的特点之一，因为在Angular1.x的出现，并没有明确提出组件的思想，只是有一个类似的<strong>指令思想</strong>来实现组件化的方式。所以，当React中明确提出<strong>组件</strong>思想后，前端好像重生了（吹的有点大了）。</p>
<h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>React中实现组件有两种方式，一种是<strong>createClass</strong>方法，另一种是通过ES2015的思想<strong>类继承React.Component</strong>来实现。</p>
<h4 id="createClass方式实现"><a href="#createClass方式实现" class="headerlink" title="createClass方式实现"></a>createClass方式实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</div><div class="line">render() &#123;</div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;div&gt;hello5&lt;/div&gt;</div><div class="line">)</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样，一个组件就创建完成，并且通过ES2015的模块化思想将其暴露出去了，其他组件就可以引入并使用了。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'./hello.jsx'</span>;</div><div class="line"></div><div class="line">ReactDom.render(</div><div class="line">&lt;Hello/&gt;,</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>);</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>OK，这样就使用简单使用了一个组件。</p>
<h4 id="类继承React-Component来实现"><a href="#类继承React-Component来实现" class="headerlink" title="类继承React.Component来实现"></a>类继承React.Component来实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">render() &#123;</div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;div className="comment"&gt;</div><div class="line">&lt;span&gt;&#123; this.props.author &#125;&lt;/span&gt;</div><div class="line">&lt;span&gt;&#123; this.props.date &#125;&lt;/span&gt;</div><div class="line">&lt;div&gt;&#123; this.props.children &#125;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; CommentItem <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</div></pre></td></tr></table></figure>
<p>需要注意的是，这样创建组件的时候，组件名称首字母必须大写（如：CommentItem）。同样，我们使用一下这个组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> CommentItem <span class="keyword">from</span> <span class="string">'./comment-item'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">render() &#123;</div><div class="line"><span class="keyword">let</span> CommentNodes = <span class="keyword">this</span>.props.data.map(<span class="function">(<span class="params">comment, index</span>) =&gt;</span> &#123;</div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;CommentItem key=&#123;index&#125; author=&#123;comment.author&#125; date=&#123;comment.date&#125;&gt;</div><div class="line">&#123;comment.content&#125;</div><div class="line">&lt;/CommentItem&gt;</div><div class="line">)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;div&gt;</div><div class="line">&#123; CommentNodes &#125;</div><div class="line">&lt;/div&gt;</div><div class="line">)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; CommentList <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</div></pre></td></tr></table></figure></p>
<p>这样我们又创建了一个组件，并且在这个组件中我们使用了上面创建的那个组件。</p>
<h3 id="组件之间的数据流"><a href="#组件之间的数据流" class="headerlink" title="组件之间的数据流"></a>组件之间的数据流</h3><p>在上面<strong>类继承React.Component来实现</strong>一节中，我们可以看出例子中出现了组件嵌套的情况，仔细想想，组件之间传递信息肯定是必然的。那么React是怎样进行<strong>组件之间的数据通信</strong>的呢？</p>
<p>回答这个问题之前，我们需要考虑一下，组件之间有几种数据通信。首先，第一种比较容易想到，那就是<strong>父子组件</strong>之间的数据通信。第二种也就自然而然的出来了—-<strong>非父子组件</strong>之间的数据通信。</p>
<h4 id="父子组件数据通信"><a href="#父子组件数据通信" class="headerlink" title="父子组件数据通信"></a>父子组件数据通信</h4><p>父子组件之间的数据通信细分其实还有两种：<strong>父与子之间</strong>和<strong>子与父之间</strong>。</p>
<p>在React中，<strong>父与子</strong>之间的数据通信是通过<strong>props属性</strong>就行传递的；<br>而<strong>子与父</strong>之间的数据通信可以通过<strong>父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据</strong>来通信;</p>
<p>下面我们来分别通过例子来再现一下这种场景：<br><strong>父组件</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> CommentItem <span class="keyword">from</span> <span class="string">'./comment-item'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">render() &#123;</div><div class="line"><span class="keyword">let</span> CommentNodes = <span class="keyword">this</span>.props.data.map(<span class="function">(<span class="params">comment, index</span>) =&gt;</span> &#123;</div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;CommentItem key=&#123;index&#125; author=&#123;comment.author&#125; date=&#123;comment.date&#125;&gt;</div><div class="line">&#123;comment.content&#125;</div><div class="line">&lt;/CommentItem&gt;</div><div class="line">)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;div&gt;</div><div class="line">&#123; CommentNodes &#125;</div><div class="line">&lt;/div&gt;</div><div class="line">)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; CommentList <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</div></pre></td></tr></table></figure></p>
<p><strong>子组件</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">render() &#123;</div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;div className="comment"&gt;</div><div class="line">&lt;span&gt;&#123; this.props.author &#125;&lt;/span&gt;</div><div class="line">&lt;span&gt;&#123; this.props.date &#125;&lt;/span&gt;</div><div class="line">&lt;div&gt;&#123; this.props.children &#125;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; CommentItem <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</div></pre></td></tr></table></figure></p>
<p>通过上面我们可以看出，子组件CommentItem需要父组件传过来的值进行展示，而父组件是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;CommentItem key=&#123;index&#125; author=&#123;comment.author&#125; date=&#123;comment.date&#125;&gt; &#123;comment.content&#125; &lt;<span class="regexp">/CommentItem&gt;</span></div></pre></td></tr></table></figure></p>
<p>在父组件中添加了<code>key</code>、<code>author</code>、<code>date</code>属性来向子组件传值。想对象的，子组件通过props对象来获取父组件传过来的值，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;&#123; this.props.author &#125;&lt;/span&gt;</div><div class="line">&lt;span&gt;&#123; this.props.date &#125;&lt;/span&gt;</div><div class="line">&lt;div&gt;&#123; this.props.children &#125;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>好的，我们再来看一下另一种<strong>子与父</strong>之间的通信。</p>
<p><strong>父组件</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> CommentList <span class="keyword">from</span> <span class="string">'./comment-list'</span>;</div><div class="line"><span class="keyword">import</span> CommentForm <span class="keyword">from</span> <span class="string">'./comment-form'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentBox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line"><span class="keyword">super</span>(props);</div><div class="line"><span class="keyword">this</span>.state = &#123;<span class="attr">data</span>: []&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">handleCommentSubmit(comment) &#123;</div><div class="line"><span class="keyword">let</span> comments = <span class="keyword">this</span>.state.data;</div><div class="line">comments.push(comment);</div><div class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">data</span>: comments&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">render() &#123;</div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;div className="m-index"&gt;</div><div class="line">&lt;div&gt;</div><div class="line">&lt;h1&gt;评论&lt;/h1&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;CommentList data=&#123;this.state.data&#125; /&gt;</div><div class="line">&lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit.bind(this)&#125; /&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export &#123; CommentBox as default &#125;;</div></pre></td></tr></table></figure></p>
<p><strong>子组件</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">handleClick()&#123;</div><div class="line"><span class="keyword">let</span> author = <span class="keyword">this</span>.refs.author.value,</div><div class="line">content = <span class="keyword">this</span>.refs.content.value;</div><div class="line"></div><div class="line"><span class="keyword">this</span>.props.onCommentSubmit(&#123;author, content, <span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;);</div><div class="line"></div><div class="line"><span class="keyword">this</span>.refs.author.value = <span class="string">""</span>;</div><div class="line"><span class="keyword">this</span>.refs.content.value = <span class="string">""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render() &#123;</div><div class="line"><span class="keyword">return</span> (</div><div class="line">&lt;div className="yo-list yo-list-a"&gt;</div><div class="line">&lt;label className="item item-input"&gt;</div><div class="line">&lt;input type="text" className="yo-input flex" ref="author" placeholder="发布人" /&gt;</div><div class="line">&lt;/label&gt;</div><div class="line">&lt;label className="item item-input"&gt;</div><div class="line">&lt;textarea className="yo-input flex" ref="content" placeholder="留言内容"&gt;&lt;/textarea&gt;</div><div class="line">&lt;/label&gt;</div><div class="line">&lt;label&gt;</div><div class="line">&lt;button onClick=&#123;this.handleClick.bind(this)&#125; className="yo-btn yo-btn-l"&gt;发表评论&lt;/button&gt;</div><div class="line">&lt;/label&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export &#123; CommentForm as default &#125;;</div></pre></td></tr></table></figure></p>
<p>简单解释一下，子组件是一个表单组件，父组件中引用了该表单子组件，然后子组件中点击button按钮，触发子组件中的处理函数，处理函数通过<strong>refs</strong>获取到表单输入值然后调用父组件中传过来的函数，从而触发父组件中的函数执行改变data数据，data数据变动直接影响的是另一个组件CommentList的变化。</p>
<p>需要注意的是，在获取表单控件内的数据时，我们利用了一个<strong>refs</strong>对象，该对象用于获取真实DOM结构。具体来说就是，在React中组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM，这是React探索性的创新）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff （详细了解<a href="http://www.infoq.com/cn/articles/react-dom-diff" target="_blank" rel="external">diff 算法</a>），它可以极大提高网页的性能表现。<br>在这里点击button时，input和textarea元素还是虚拟DOM，所以违法获取到输入的值，需要通过<strong>refs</strong>对象获取一下。</p>
<h4 id="非父子组件之间的通信"><a href="#非父子组件之间的通信" class="headerlink" title="非父子组件之间的通信"></a>非父子组件之间的通信</h4><p>React中在处理<strong>非父子组件之间的通信</strong>时，简单的，嵌套不深的非父子组件（如：兄弟组件）可以仍然使用上一节<strong>非父子组件之间通信</strong>中的<strong>事件函数，传形参</strong>的方式来实现。如子组件<strong>CommentList </strong>和子组件<strong>CommentFrom</strong>之间的通信就是这样实现的。</p>
<p>如果，需要通信的两个非父子组件之间嵌套比较深，可以使用Flux和Redux来实现状态管理，这里不做详细阐述，下面会详细对比vue的状态管理进行说明。想先了解的可以看一下阮一峰老师的blog：</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="external">Flux 架构入门教程</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">Redux 入门教程（一）：基本用法</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="external">Redux 入门教程（二）：中间件与异步操作</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="external">Redux 入门教程（三）：React-Redux 的用法</a></p>
</blockquote>
<h3 id="组件的声明周期"><a href="#组件的声明周期" class="headerlink" title="组件的声明周期"></a>组件的声明周期</h3><p><img src="http://upload-images.jianshu.io/upload_images/3333422-04ea055c73c50c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="react 组件的声明周期"></p>
<p>上面这张图已经很清楚的展示了react组件的声明周期了，就不过多介绍了。这张图摘自<a href="http://www.jianshu.com/p/4784216b8194" target="_blank" rel="external">React组件生命周期小结</a>，对于理解React组件的声明周期钩子函数很有帮助。</p>
<h2 id="Vue中的组件和数据流"><a href="#Vue中的组件和数据流" class="headerlink" title="Vue中的组件和数据流"></a>Vue中的组件和数据流</h2><p>Vue比React出来的要晚一些，自然顺应了前端组件化的大潮，并且个人觉得借鉴了部分React的思想来实现其组件化思想。</p>
<p>Vue默认的是单向数据流，这是Vue直接提出来说明的，父组件默认可以向子组件传递数据，但是子组件向父组件传递数据就需要额外设置了。</p>
<p><strong>父子组件</strong>之间的数据通信是通过<strong>Prop</strong>和<strong>自定义事件</strong>实现的，而<strong>非父子组件</strong>可以使用<strong>订阅/发布</strong>模式实现（类似于Angualr中的非父子指令之间的通信），再复杂一点也是建议使用状态管理（vuex）。</p>
<p>我一直觉得Vue的官方文档是我看过最直接、易懂的技术文档，所以就直接给大家贴一个中文链接，自己去跟随尤雨溪学习吧。</p>
<blockquote>
<p><a href="https://vuefe.cn/v2/guide/components.html" target="_blank" rel="external">Vue 中的组件和数据流</a></p>
</blockquote>
<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><p>上面对比React和Vue的<strong>组件及数据流</strong>的时候，都提到了<strong>当非父子组件之间嵌套过深</strong>的时候都建议使用状态管理来维护数据的变化，那么到底它们之间的状态管理有什么区别呢？</p>
<h2 id="Vue中的状态管理–vuex"><a href="#Vue中的状态管理–vuex" class="headerlink" title="Vue中的状态管理–vuex"></a>Vue中的状态管理–vuex</h2><p>先放个<a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">官方中文链接</a>，还是建议直接看官方文档。然后在放一下小例子去体会一下。</p>
<p>先简单说明一下，vuex状态管理的几个核心概念：</p>
<ol>
<li>State: Vuex 使用 <strong>单一状态树</strong> —— 是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个『唯一数据源(<a href="https://en.wikipedia.org/wiki/Single_source_of_truth" target="_blank" rel="external">SSOT</a>)』而存在。这也意味着，每个应用将仅仅包含一个 store 实例。</li>
<li>Getters: 从state中获取状态值</li>
<li>Mutation: 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数</li>
<li>Action:  类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</li>
</ol>
<p>例子来了：<br><strong>store.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'../libs/vue.js'</span>;</div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'../libs/vuex.min.js'</span>;</div><div class="line">Vue.use(Vuex);</div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line"><span class="attr">loginPrePath</span>:[<span class="string">'/'</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> mutations =&#123;</div><div class="line">LOGINPREPATH(state,path)&#123;</div><div class="line">state.loginPrePath.unshift(path);</div><div class="line">&#125;,</div><div class="line">LOGINPREPATHSHIFT(state)&#123;</div><div class="line">state.loginPrePath.shift();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">state,</div><div class="line">mutations</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>actions.js:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line"><span class="attr">loginPrePath</span>: <span class="function">(<span class="params">&#123;dispatch,state&#125;,path</span>)=&gt;</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'actions loginPrePath:'</span> +path);</div><div class="line">dispatch(<span class="string">'LOGINPREPATH'</span>,path);</div><div class="line">&#125;,</div><div class="line"><span class="attr">loginPrePathShift</span>: <span class="function">(<span class="params">&#123;dispatch,state&#125;</span>)=&gt;</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'delete....'</span>);</div><div class="line">dispatch(<span class="string">'LOGINPREPATHSHIFT'</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>getter.js:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line"><span class="attr">loginPrePath</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.loginPrePath</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>login.vue:</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">...</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">import Vue from '../libs/vue.js';</div><div class="line">import VueResource from '../libs/vue-resource.js';</div><div class="line">import Vuex from '../vuex/actions.js';</div><div class="line">import VuexGet from '../vuex/getters.js';</div><div class="line"></div><div class="line">Vue.use(VueResource);</div><div class="line">export default &#123;</div><div class="line">data()&#123;</div><div class="line">return &#123;</div><div class="line">username: '',</div><div class="line">password: '',</div><div class="line">loginBtn: 0</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">vuex: &#123;</div><div class="line">actions: &#123;</div><div class="line">setLoginPrePath: Vuex.loginPrePath</div><div class="line">&#125;,</div><div class="line">getters:&#123;</div><div class="line">getLoginPrePath: VuexGet.loginPrePath</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">forget()&#123;</div><div class="line">//使用vuex，修改状态值</div><div class="line">this.setLoginPrePath(&#123;path:this.$route.path,title:'忘记密码'&#125;);</div><div class="line">this.$router.go(&#123;path:'/index2/forget.json'&#125;);</div><div class="line">&#125;,</div><div class="line">submit()&#123;</div><div class="line">if(this.loginBtn === 3)&#123;</div><div class="line">if(this.checked)&#123;</div><div class="line">this.$http.post('/zhixiao/password.json',&#123;password:this.password&#125;).then(</div><div class="line">(res)=&gt;&#123;</div><div class="line">if(res.ok)&#123;</div><div class="line">console.log("注册成功，正在跳转登录页面");</div><div class="line">setTimeout(()=&gt;&#123;</div><div class="line">//获取状态值，通过getter</div><div class="line">var path = this.getLoginPrePath[0].path;</div><div class="line">this.loginPrePathShift();</div><div class="line">this.$router.go(path);</div><div class="line">&#125;,1500);</div><div class="line">&#125;</div><div class="line">&#125;,(res)=&gt;&#123;</div><div class="line">console.log('网络错误，请稍后重试');</div><div class="line">&#125;</div><div class="line">)</div><div class="line">&#125;else&#123;</div><div class="line">console.log('请选择同意用户协议');</div><div class="line">&#125;</div><div class="line">&#125;else&#123;</div><div class="line">console.log('请填写验证码');</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>上面的例子并无实际效果，是我从以前项目中拼出来的（vuex1.0），只是为了说明<strong>loginPrePath</strong>这个状态值在vuex中的使用方式。详细请看Vue官方文档。</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>要想实现SPA，路由是个不可避免的话题，作为主流的MVVM框架，怎么可能没有官方路由呢，两者的路由也很相似，都是利用各自的组件实现思想来实现的。</p>
<h2 id="Vue中的路由"><a href="#Vue中的路由" class="headerlink" title="Vue中的路由"></a>Vue中的路由</h2><p>还是先贴<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="external">官方链接</a>，简单易懂。<br>再给个例子(vue-router1.0)，仔细看一下：<br><strong>app.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//引用component</span></div><div class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">'./components/index.vue'</span>;</div><div class="line"><span class="keyword">import</span> main <span class="keyword">from</span> <span class="string">'./components/main.vue'</span>;</div><div class="line"><span class="keyword">import</span> my <span class="keyword">from</span> <span class="string">'./components/my.vue'</span>;</div><div class="line"></div><div class="line"><span class="comment">//APP route</span></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./libs/vue.js'</span>;</div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'./libs/vue-router.js'</span>;</div><div class="line"></div><div class="line">Vue.use(VueRouter);</div><div class="line"></div><div class="line">router.map(&#123;</div><div class="line"><span class="string">'/'</span>:&#123;</div><div class="line"><span class="attr">component</span>: index,</div><div class="line"><span class="attr">subRoutes</span>:&#123;</div><div class="line"><span class="string">'/'</span>:&#123;</div><div class="line"><span class="attr">component</span>: main</div><div class="line">&#125;,</div><div class="line"><span class="string">'/my'</span>:&#123;</div><div class="line"><span class="attr">name</span>:<span class="string">'my'</span>,</div><div class="line"><span class="attr">component</span>: my</div><div class="line">&#125;,</div><div class="line"><span class="string">'/results/:key'</span>:&#123;</div><div class="line"><span class="attr">name</span>:<span class="string">'results'</span>,</div><div class="line"><span class="attr">component</span>:results</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//启动router</span></div><div class="line">router.start(App,<span class="string">'body'</span>);</div></pre></td></tr></table></figure></p>
<p><strong>index.vue</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">&lt;div class="box"&gt;</div><div class="line">&lt;div class="index-container"&gt;</div><div class="line">&lt;router-view&gt;</div><div class="line"></div><div class="line">&lt;/router-view&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;footer id="footer"&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">&lt;li v-bind:class="getIndex == $index ? 'active' : ''"</div><div class="line">v-for="data in navList"</div><div class="line">v-on:click="changePage($index)"</div><div class="line">v-link="&#123;path:data.path,exact: true&#125;"&gt;</div><div class="line">&lt;i class="iconfont"&gt;&#123;&#123;&#123;data.icon&#125;&#125;&#125;&lt;/i&gt;</div><div class="line">&lt;p&gt;&#123;&#123;&#123;data.name&#125;&#125;&#125;&lt;/p&gt;</div><div class="line">&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;/footer&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'../libs/vue.js'</span>);</div><div class="line"><span class="keyword">var</span> VueResource = <span class="built_in">require</span>(<span class="string">'../libs/vue-resource.js'</span>);</div><div class="line"><span class="keyword">import</span> &#123;getIndex&#125; <span class="keyword">from</span> <span class="string">'../vuex/getters.js'</span>;</div><div class="line"><span class="keyword">import</span> &#123;changeIndexPage&#125; <span class="keyword">from</span> <span class="string">'../vuex/actions.js'</span>;</div><div class="line">Vue.use(VueResource);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line"><span class="attr">vuex</span>: &#123;</div><div class="line"><span class="attr">actions</span>:&#123;</div><div class="line">changeIndexPage</div><div class="line">&#125;,</div><div class="line"><span class="attr">getters</span>:&#123;</div><div class="line">getIndex</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">data()&#123;</div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line"><span class="attr">cur</span>: <span class="number">0</span>,</div><div class="line"><span class="attr">navList</span>:[</div><div class="line">&#123;<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">icon</span>:<span class="string">''</span>,<span class="attr">name</span>:<span class="string">'主页'</span>&#125;,</div><div class="line">&#123;<span class="attr">path</span>:<span class="string">'/lee'</span>,<span class="attr">icon</span>:<span class="string">''</span>,<span class="attr">name</span>:<span class="string">'排行榜'</span>&#125;,</div><div class="line">&#123;<span class="attr">path</span>:<span class="string">'/search'</span>,<span class="attr">icon</span>:<span class="string">''</span>,<span class="attr">name</span>:<span class="string">'发现'</span>&#125;,</div><div class="line">&#123;<span class="attr">path</span>:<span class="string">'/my'</span>,<span class="attr">icon</span>:<span class="string">''</span>,<span class="attr">name</span>:<span class="string">'我的'</span>&#125;</div><div class="line">]</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line"><span class="attr">methods</span>:&#123;</div><div class="line"><span class="attr">changePage</span>:<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.changeIndexPage(i);</div><div class="line"><span class="keyword">this</span>.cur = <span class="keyword">this</span>.getIndex;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>大概就这样，感觉像是配置的感觉，其实这就是利用的vue中组件思想来实现的，详细看官方文档。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1.过渡系统<br>2.服务端渲染</p>
<h2 id="过渡系统"><a href="#过渡系统" class="headerlink" title="过渡系统"></a>过渡系统</h2><p><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/transitions.html</a></p>
<p><a href="https://cn.vuejs.org/v2/guide/transitioning-state.html" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/transitioning-state.html</a></p>
<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>说道服务端渲染，其实官方对于使用SSR的原因和好处，解释的都很好，有兴趣的可以看一看 <a href="https://cn.vuejs.org/v2/guide/ssr.html" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/ssr.html</a></p>
<p>另外官方提供的服务端渲染的例子vue-hackernews2.0也很不错的，可以去借鉴看一看<br><a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="external">https://github.com/vuejs/vue-hackernews-2.0</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在我也是在搬砖阶段，深入的理解可能还需要一些时间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git命令和错误集锦]]></title>
      <url>https://jane0219.github.io/2016/09/25/Git%20%E5%91%BD%E4%BB%A4%E5%92%8C%E9%94%99%E8%AF%AF%E9%9B%86%E9%94%A6/</url>
      <content type="html"><![CDATA[<h3 id="Git-命令和错误集锦"><a href="#Git-命令和错误集锦" class="headerlink" title="Git 命令和错误集锦"></a>Git 命令和错误集锦</h3><hr>
<h4 id="前话：安装git"><a href="#前话：安装git" class="headerlink" title="前话：安装git"></a>前话：安装git</h4><p>官方网站下载：<br><a href="http://code.google.com/p/msysgit/downloads/list" target="_blank" rel="external">http://code.google.com/p/msysgit/downloads/list</a></p>
<p> 下载安装包后，打开执行，然后一路next.<br> 安装完成后，在桌面右键会出现 git bash here的标志和字样，说明安装成功。<br><a id="more"></a><br>然后我们就需要与远程的github相连接，才能进行本地管理。这仅需要三步：<br><code>$ git config --global user.name 你的github名称</code><br><code>$ git config --global user.email 你注册github的邮箱</code></p>
<p> 注意：这里的–global代表你电脑的所有本地仓库都会使用你的这个配置。</p>
<p>然后执行 $ssh-keygen -t rsa -C “你的邮箱”这里会让你输入密码，我们选择默认直接enter就行，不然之后可能会报错。<br>执行完后这时候会在你的电脑的 C/用户/Adiministor/.ssh/id_rsa.pub 生成这个key文件（id_rsa.pub）<br><img src="/images/1474722294367.png" alt="Alt text"></p>
<p>找到打开它，复制里面的代码然后到你的github上，右侧点击头像下面的setting<br><img src="/images/1474722248866.png" alt="Alt text"><br>然后点击左边栏的SSH and GPG key<br><img src="/images/1474722385417.png" alt="Alt text"><br>然后点击new SSH key进行key添加，把你电脑上的key粘贴到key下面的内容区，然后点 add ssh key<br><img src="/images/1474722569368.png" alt="Alt text"></p>
<p>至此你本地已经和github链接上了</p>
<hr>
<h4 id="（一）向远端提交项目："><a href="#（一）向远端提交项目：" class="headerlink" title="（一）向远端提交项目："></a>（一）向远端提交项目：</h4><h6 id="如果之前没有建立本地仓库的话先执行这里："><a href="#如果之前没有建立本地仓库的话先执行这里：" class="headerlink" title="如果之前没有建立本地仓库的话先执行这里："></a>如果之前没有建立本地仓库的话先执行这里：</h6><p>在桌面右击 git bash here   //（已经装过git了）<br>mkdir 文件夹名   //新建文件夹（作为本地仓库）<code>比如：mkdir project</code><br> cd project           //进入文件夹<br>git init             //初始化本地仓库</p>
<h6 id="如果已经有本地仓库了，从这部开始就行"><a href="#如果已经有本地仓库了，从这部开始就行" class="headerlink" title="如果已经有本地仓库了，从这部开始就行:"></a>如果已经有本地仓库了，从这部开始就行:</h6><p>git add 文件名/<em>  ( “ </em> ” 代表所有文件)<br>git commit –m “解释说明” （解释必须带上，避免进入文件编辑界面，如果进去了按ESC 然后：wq,再回车）<br>git remote add origin 远程地址 //建立远程连接<br>git push –set-upstream origin master<br>git push</p>
<p>至此如果没有出错的话文件就提交到远程版本库了</p>
<hr>
<h4 id="（二）建立分支："><a href="#（二）建立分支：" class="headerlink" title="（二）建立分支："></a>（二）建立分支：</h4><p>提醒：一般工作之后master上边的东西我们是没有权限更改的（那是QA的辖域），所以在master基础上需要建立自己的分支，在自己的分支上对项目进行更改。</p>
<h5 id="分值操作："><a href="#分值操作：" class="headerlink" title="分值操作："></a>分值操作：</h5><p>git checkout –b 分支名  //在master基础上复制一条分支来，并切换到新分支上<br>git checkout 分支名   //切换到指定分支<br>git branch    //查看分支<br>git branch –a   //查看包括远程的（包括别人建立的）所有分支<br>git merge master   //将自己的项目与master上的东西进行合并（为了避免别人也更改了项目，master东西被更改了）</p>
<hr>
<h4 id="（三）常用命令："><a href="#（三）常用命令：" class="headerlink" title="（三）常用命令："></a>（三）常用命令：</h4><p>ls  //显示所在文件夹的所有文件<br>mkdir // 新建一个文件夹<br>touch  //新建一个文件(不是文件夹)<br>git status   //查看当前状态<br>rm 删除  //（慎用）</p>
<hr>
<h4 id="（四）提交文件常见错误："><a href="#（四）提交文件常见错误：" class="headerlink" title="（四）提交文件常见错误："></a>（四）提交文件常见错误：</h4><p>1  执行git remote add origin git@github.com:jane0219/test.git时报错：<br><code>fatal: remote origin already exists.</code><br>解决：执行git remote rm origin   //删除远程主机名</p>
<p>2.执行 git push 时报<br><code>fatal: The current branch master has no upstream branch.</code><br>解决：执行 git push –set-upstream origin master  //与远程master建立连接</p>
<p>3.执行git push –set-upstream origin master市报错：<br>        <code>! [rejected]        master -&gt; master (fetch first)  
error: failed to push some refs to &#39;git@github.com:jane0219/test.git&#39;</code></p>
<p>解决： git pull “远程地址” 再执行git add … //本地更改文件或者上传新文件前要先跟版本库的东西进行merge 合并，远程版本库有的东西本地仓库没有的话会报错（原因还不敢确定）</p>
<ol>
<li>git pull 时报错：<br><code>refusing to merge unrelated histories</code></li>
</ol>
<p>解决：执行git pull origin master –allow-unrelated-histories //让git接受合并跟之前的项目的 无关项（以前的文件里没有的东西）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown语法指南]]></title>
      <url>https://jane0219.github.io/2016/09/25/markdown%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h3 id="markdown语法指南"><a href="#markdown语法指南" class="headerlink" title="markdown语法指南"></a>markdown语法指南</h3><hr>
<h4 id="入门说明："><a href="#入门说明：" class="headerlink" title="入门说明："></a>入门说明：</h4><hr>
<p>定义：markdown 是一种轻量级标记语言，可以使用普通文本编辑器进行编辑的纯文本编辑语言。它可以把一篇纯文本文章转化为富文本，让读者得到清晰明了的阅读体验。<br>用途：markdown的语法简洁明了，所以很多人用它来写博客，就像我一样。</p>
<a id="more"></a>
<p>  它还可以用来编写说明文档，比如很多的readme文档都是用它写的。</p>
<p>除此之外因为我们还有markdownPad和马克飞象这样的工具，所以我们可以随意将自己写的文件输出为html文件、或者psd文件等。</p>
<h4 id="语法指南"><a href="#语法指南" class="headerlink" title="语法指南"></a>语法指南</h4><hr>
<h5 id="（一）特殊字符处理"><a href="#（一）特殊字符处理" class="headerlink" title="（一）特殊字符处理"></a>（一）特殊字符处理</h5><p>在html文件中，有两个字符需要特殊处理，那就是：&lt; 和&amp;   。“&lt;”符号在html里是用作一个标签的开始符号，而“&amp;”符号用于标记html实体，<code>&amp;lt;</code>代表”&lt;”。<br>而markdown让你更自然的书写字符，需要转换的它会处理好。它会保留原状。</p>
<hr>
<h5 id="（二）换行"><a href="#（二）换行" class="headerlink" title="（二）换行"></a>（二）换行</h5><p>这里的换行方法是要分情况的;</p>
<h6 id="（1）六级标题下的换行"><a href="#（1）六级标题下的换行" class="headerlink" title="（1）六级标题下的换行"></a>（1）六级标题下的换行</h6><p>只需要回车（enter）一下就可以了换行了，so easy~</p>
<h6 id="（2）其他格式下"><a href="#（2）其他格式下" class="headerlink" title="（2）其他格式下"></a>（2）其他格式下</h6><p>不是六级标题下的话就需要，在你现在所在行敲两个或两个以上空格，或者一个tab键，再回车才可以实现换行。</p>
<hr>
<h5 id="（三）文字加粗"><a href="#（三）文字加粗" class="headerlink" title="（三）文字加粗"></a>（三）文字加粗</h5><h6 id="（1）利用-“-”-加粗"><a href="#（1）利用-“-”-加粗" class="headerlink" title="（1）利用  “#”  加粗"></a>（1）利用  “#”  加粗</h6><p>在markdown里要实现六级标题很简单，只要在你所写的文字前面加上  “#”  就可以。一个  “#”  号代表一级标题，一次两个代表二级标题……（#后面要加一个空格）例如：</p>
<pre><code># 我是一级标题
## 我是二级标题
### 我是三级标题 
</code></pre><p>对应效果：<br><img src="/images/1474192521970.png" alt="Alt text"></p>
<h6 id="（2）利用下滑线-“-”或者-“—”"><a href="#（2）利用下滑线-“-”或者-“—”" class="headerlink" title="（2）利用下滑线  “===”或者 “—”"></a>（2）利用下滑线  “===”或者 “—”</h6><p>a.  “==”  出来的效果是一级标题<br>例如：</p>
<p><img src="/images/1474193802503.png" alt="Alt text"></p>
<p>b.  “–”出来的效果是二级标题<br><img src="/images/1474194148265.png" alt="Alt text"></p>
<p><span style="font-size:20px;">*</span>注意：无论是用双下滑线还是单下划线 ，都需要写两个或者两个以上才可以。</p>
<p>c.  用<strong>     </strong>包起来，比如：<br><code>**hello**</code><br>效果：<strong>hello</strong><br>d.  用<strong>       </strong>包起来，比如：<br><code>__hello__</code><br>效果：<strong>hello</strong><br>注：前后都是两个_或者*，如果是一个的话显示斜体。</p>
<hr>
<h5 id="（四）区块引用"><a href="#（四）区块引用" class="headerlink" title="（四）区块引用"></a>（四）区块引用</h5><p> markdown标记区块引用是使用类似email中的用&gt;的引用方式。如果你还熟悉在email新建中的引言部分，你就知道怎么在markdown中进行引用了。例如：</p>
<pre><code>&gt;假如生活欺骗了你 不要悲伤 反正明天也一样  --李晓宁
&gt; 生活不止眼前的苟且 还有读不懂的诗和到不了的远方  --李晓宁
</code></pre><p>  对应效果：</p>
<blockquote>
<p>假如生活欺骗了你  不要悲伤  反正明天也一样  –李晓宁<br>生活不止眼前的苟且  还有读不懂的诗和到不了的远方  –李晓宁</p>
</blockquote>
<h6 id="（a）区块引用可以嵌套-比如："><a href="#（a）区块引用可以嵌套-比如：" class="headerlink" title="（a）区块引用可以嵌套  比如："></a>（a）区块引用可以嵌套  比如：</h6><pre><code>&gt;生活不止眼前的苟且
   &gt;&gt;还有读不懂的诗和到不了的远方
</code></pre><p>效果：</p>
<blockquote>
<p>生活不止眼前的苟且</p>
<blockquote>
<p>还有读不懂的诗和到不了的远方</p>
</blockquote>
</blockquote>
<h6 id="（b）引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等："><a href="#（b）引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等：" class="headerlink" title="（b）引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等："></a>（b）引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</h6><pre><code>&gt;###生活不止眼前的苟且
    &gt;&gt;好友读不懂的诗和到不了的远方
</code></pre><p>效果：</p>
<blockquote>
<h3 id="生活不止眼前的苟且"><a href="#生活不止眼前的苟且" class="headerlink" title="生活不止眼前的苟且"></a>生活不止眼前的苟且</h3><blockquote>
<p>还有读不懂的诗和到不了的远方</p>
<hr>
<h5 id="（五）列表"><a href="#（五）列表" class="headerlink" title="（五）列表"></a>（五）列表</h5><h6 id="（1）无序列表："><a href="#（1）无序列表：" class="headerlink" title="（1）无序列表："></a>（1）无序列表：</h6><p>a.用  “+”  号做标记（“+” 号后一定要有空格）  例如：<br><code>+ 我的生活</code><br><code>+ 我的爱好</code></p>
</blockquote>
</blockquote>
<p>效果：</p>
<ul>
<li>我的生活</li>
<li>我的爱好</li>
</ul>
<p>b. 用 “-” 号做标记（后面也要有空格） 例如：<br><code>- 我的生活</code><br><code>- 我的爱好</code></p>
<p>效果：</p>
<ul>
<li>我的生活</li>
<li>我的爱好</li>
</ul>
<p>c.用  “<em>”  做标记（记得空格） 例如：<br>``</em> 我的生活<code>``* 我的爱好</code></p>
<p> 效果：</p>
<ul>
<li>我的生活</li>
<li>我的爱好</li>
</ul>
<h6 id="（2）有序列表"><a href="#（2）有序列表" class="headerlink" title="（2）有序列表"></a>（2）有序列表</h6><p>使用数字接着一个英文句号就OK  比如：</p>
<ol>
<li>小狗</li>
<li>小猫</li>
<li>小猪</li>
</ol>
<p>*注意：若是往列表里嵌入代码块，要首行做进至少8个空格或两个制表符。</p>
<hr>
<h5 id="（六）代码块"><a href="#（六）代码块" class="headerlink" title="（六）代码块"></a>（六）代码块</h5><h6 id="（1）用英文状态下的-nbsp-nbsp-引起来-例如："><a href="#（1）用英文状态下的-nbsp-nbsp-引起来-例如：" class="headerlink" title="（1）用英文状态下的 ``  &nbsp;&nbsp;  ``引起来,例如："></a>（1）用英文状态下的 ``  &nbsp;&nbsp;  ``引起来,例如：</h6><p><img src="/images/1474380803358.png" alt="Alt text"></p>
<p>效果：<br><img src="/images/1474380814707.png" alt="Alt text"></p>
<h6 id="（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。"><a href="#（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。" class="headerlink" title="（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。"></a>（2）一个tab键或者三个以上空格之后再回车就会生成一个代码块，会自带高亮和背景。</h6><p>比如：(注意前边空格)<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> <code>&lt;p&gt;nihao&lt;/p&gt;</code></p>
<pre><code>&lt;p&gt;nihao&lt;/p&gt;
</code></pre><hr>
<h5 id="（七）插入图片"><a href="#（七）插入图片" class="headerlink" title="（七）插入图片"></a>（七）插入图片</h5><p> Markdown 使用一种和链接（一会我们会讲）很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。</p>
<h6 id="（1）行内式"><a href="#（1）行内式" class="headerlink" title="（1）行内式"></a>（1）行内式</h6><p>语法：! [图片标题] (图片地址)<br>例如：</p>
<pre><code>! [&quot;小女孩&quot;](/images/avatar.jpg)
</code></pre><p>效果：<br><img src="/images/avatar.jpg" alt="&quot;小女孩&quot;"></p>
<h6 id="（2）参考式"><a href="#（2）参考式" class="headerlink" title="（2）参考式"></a>（2）参考式</h6><p>语法：! <a href="/images/avatar.jpg">图片标题</a><br></p>
<pre><code>[id]:url
</code></pre><p>例如：</p>
<pre><code>! [&quot;小女孩&quot;](/images/avatar.jpg)
</code></pre><p>效果：<br><img src="/images/avatar.jpg" alt="&quot;小女孩&quot;"></p>
<hr>
<p>#####（八）超链接<br>超链接的语法格式跟插入图片的格式很是相似，它也有两种链接方式：行内式和参考式<br>语法分别和图片语法相似（这里就不做详细说明，相信大家都能懂）</p>
<h6 id="1-行内式"><a href="#1-行内式" class="headerlink" title="1.行内式"></a>1.行内式</h6><p>[链接文字] (链接地址)</p>
<h6 id="2-参考式"><a href="#2-参考式" class="headerlink" title="2.参考式"></a>2.参考式</h6><p>[链接文字]  <code>[</code><a href="/images/avatar.jpg">id</a><code>]</code><br><code>[</code>id<code>]</code>:链接地址</p>
<hr>
<h5 id="（九）分割线"><a href="#（九）分割线" class="headerlink" title="（九）分割线"></a>（九）分割线</h5><p>生成分割线的方式有很多种，下面给大家介绍几种通用的方式：<br><code>***</code>(三个或三个以上“ * ”连写)<br><code>---</code>（三个或三个以上“ - ”连写）(连接线)<br><code>___</code>（三个或三个以上“ _”连写）(下滑线)</p>
<h2 id="效果分别是："><a href="#效果分别是：" class="headerlink" title=" 效果分别是："></a> 效果分别是：</h2><hr>
<hr>
<h5 id="（十）表格"><a href="#（十）表格" class="headerlink" title="（十）表格"></a>（十）表格</h5><p>对于markdown我唯一觉得不怎么舒服的地方就是表格的编写，这是一个比较累人的地方，它的书写格式有点麻烦，在这个方面它就没有html简单了。下面是markdown书写表格的语法格式：</p>
<pre><code>|table|Are |cool|
|-----|----|----|
|name |age |addr|
</code></pre><p>效果如下：<br> |table|Are|cool|<br> |—–|—|—|<br> |name|age|addr|<br> |name|age|addr|</p>
<hr>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>以上是一些比较常用的markdown语法的使用介绍，希望对大家学习markdown能带来帮助。如果有好的提议，欢迎大家跟我一起交流。</p>
<p>本人博客：<a href="http://lxning.club" target="_blank" rel="external">http://lxning.club</a><br>邮箱：lxningdou@163.com</p>
<p>出自：李晓宁</p>
]]></content>
    </entry>
    
  
  
</search>
